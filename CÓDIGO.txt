import os
import tkinter as tk
from tkinter import messagebox, filedialog
from tkinter import ttk
import subprocess
from datetime import datetime

# Função para buscar arquivos com o(s) código(s) no nome e ordenar pela data de modificação
def search_files(base_paths, search_codes):
    found_files = []
    
    for base_path in base_paths:
        for root, dirs, files in os.walk(base_path):
            for file in files:
                for search_code in search_codes:
                    if search_code in file and file.endswith('.txt'):
                        full_path = os.path.join(root, file)
                        mod_time = os.path.getmtime(full_path)
                        formatted_time = datetime.fromtimestamp(mod_time).strftime('%Y-%m-%d %H:%M:%S')
                        found_files.append((file, full_path, mod_time, formatted_time))
    
    # Ordena do mais recente para o mais antigo pela data de modificação (mod_time)
    found_files.sort(key=lambda x: x[2], reverse=True)
    
    return found_files

# Função para abrir o arquivo selecionado
def open_file(filepath):
    try:
        if os.name == 'nt':  # Windows
            os.startfile(filepath)
        else:
            subprocess.call(['xdg-open', filepath])  # Linux/Mac
    except Exception as e:
        messagebox.showwarning("Erro", f"Erro ao abrir o arquivo: {e}")

# Função para preencher a treeview com os arquivos encontrados
def populate_tree():
    search_codes = entry_code.get().strip().split(',')
    if not search_codes or search_codes == ['']:
        messagebox.showwarning("Entrada Vazia", "Por favor, insira um ou mais códigos para buscar.")
        return
    
    if not selected_base_paths:
        messagebox.showwarning("Nenhum Caminho", "Por favor, selecione pelo menos um caminho base.")
        return
    
    for item in tree.get_children():
        tree.delete(item)
    
    files = search_files(selected_base_paths, search_codes)
    
    if not files:
        messagebox.showinfo("Nenhum Arquivo Encontrado", f"Nenhum arquivo encontrado com os códigos: {search_codes}")
        return
    
    for idx, (filename, path, mod_time, formatted_time) in enumerate(files):
        tree.insert('', 'end', iid=idx, values=(filename, formatted_time, path))

# Função ao clicar no item da lista
def on_item_click(event):
    selected_items = tree.selection()
    if not selected_items:
        return
    
    selected_item = selected_items[0]
    file_path = tree.item(selected_item, 'values')[2]
    open_file(file_path)

# Função para selecionar pastas base personalizadas
def select_base_paths():
    folder_selected = filedialog.askdirectory()
    if folder_selected:
        selected_base_paths.append(folder_selected)
        lbl_base_paths.config(text="Caminhos base adicionais:\n" + "\n".join(selected_base_paths))

# Função para adicionar um caminho selecionado a partir de um botão
def add_predefined_path(path):
    if path not in selected_base_paths:
        selected_base_paths.append(path)
        lbl_base_paths.config(text="Caminhos Selecionados:\n" + "\n".join(selected_base_paths))

# Caminhos base predefinidos
predefined_paths = [
    r"\\Fswcorp\ceic\DFEPJ\GAGIRE\22 - CARGA\arquivos_processados\cadastros\202410",
    r"\\Fswcorp\ceic\DFEPJ\GAGIRE\22 - CARGA\arquivos_processados\forcados\202410",
    r"\\Fswcorp\ceic\DFEPJ\GAGIRE\22 - CARGA\arquivos_processados\metas\202410",
    r"\\Fswcorp\ceic\DFEPJ\GAGIRE\22 - CARGA\arquivos_processados\Tombamento",
    r"\\Fswcorp\ceic\DFEPJ\GAGIRE\22 - CARGA\arquivos_processados\vps\202410"
]

selected_base_paths = []  # Lista de caminhos selecionados

# Interface gráfica
root = tk.Tk()
root.title("Buscar Arquivos por Código")
root.geometry("800x600")

# Frame de controle para entrada de código e botões
control_frame = ttk.Frame(root)
control_frame.pack(padx=10, pady=10, fill=tk.X)

# Botão para selecionar pastas base personalizadas
btn_select_paths = ttk.Button(control_frame, text="Selecionar Caminhos Base Adicionais", command=select_base_paths)
btn_select_paths.pack(side=tk.LEFT)

# Label para mostrar os caminhos base selecionados
lbl_base_paths = ttk.Label(root, text="Caminhos Selecionados: Nenhum selecionado", anchor="w", justify="left")
lbl_base_paths.pack(fill=tk.X, padx=10, pady=5)

# Label e entrada para o código de busca
label_code = ttk.Label(control_frame, text="Código(s) de Busca:")
label_code.pack(side=tk.LEFT, padx=5)
entry_code = ttk.Entry(control_frame, width=40)
entry_code.pack(side=tk.LEFT, padx=5)
entry_code.bind('<Return>', lambda event: populate_tree())  # Permite buscar pressionando Enter

# Botão para carregar arquivos
btn_load = ttk.Button(control_frame, text="Buscar Arquivos", command=populate_tree)
btn_load.pack(side=tk.LEFT)

# Frame para os botões dos caminhos predefinidos
button_frame = ttk.LabelFrame(root, text="Selecione os Caminhos Predefinidos", padx=10, pady=10)
button_frame.pack(fill=tk.X, padx=10, pady=10)

# Adiciona botões para cada caminho predefinido
for path in predefined_paths:
    btn = ttk.Button(button_frame, text=path, command=lambda p=path: add_predefined_path(p))
    btn.pack(anchor='w', pady=5)

# Frame para Treeview e Scrollbar
tree_frame = ttk.Frame(root)
tree_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

# Scrollbar vertical
tree_scroll_y = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL)
tree_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)

# Scrollbar horizontal
tree_scroll_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)

# Treeview para listar os arquivos encontrados
tree = ttk.Treeview(tree_frame, columns=['Nome do Arquivo', 'Data de Modificação', 'Caminho Completo'], 
                    yscrollcommand=tree_scroll_y.set, xscrollcommand=tree_scroll_x.set)

tree.heading('Nome do Arquivo', text='Nome do Arquivo')
tree.heading('Data de Modificação', text='Data de Modificação')
tree.heading('Caminho Completo', text='Caminho Completo')

tree.column('Nome do Arquivo', anchor='w', width=250)
tree.column('Data de Modificação', anchor='center', width=150)
tree.column('Caminho Completo', anchor='w', width=400)

tree.pack(fill=tk.BOTH, expand=True)

# Configuração das scrollbars
tree_scroll_y.config(command=tree.yview)
tree_scroll_x.config(command=tree.xview)

# Bind para detectar duplo clique no item da lista
tree.bind("<Double-1>", on_item_click)

# Iniciar a interface
root.mainloop()