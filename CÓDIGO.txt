import os
import tkinter as tk
from tkinter import messagebox, filedialog
from tkinter import ttk
import subprocess
from datetime import datetime

# Função para buscar arquivos com o código no nome e ordenar pela data de modificação
def search_files(base_path, search_code):
    found_files = []
    for root, dirs, files in os.walk(base_path):
        for file in files:
            if search_code in file and file.endswith(".txt"):
                full_path = os.path.join(root, file)
                try:
                    mod_time = os.path.getmtime(full_path)
                    formatted_time = datetime.fromtimestamp(mod_time).strftime('%d de %B de %Y')
                    found_files.append((file, full_path, mod_time, formatted_time))
                except Exception as e:
                    print(f"Erro ao acessar o arquivo {full_path}: {e}")
    
    # Ordena do mais recente para o mais antigo pela data de modificação (mod_time)
    found_files.sort(key=lambda x: x[2], reverse=True)
    
    return found_files

# Função para abrir o arquivo selecionado
def open_file(filepath):
    try:
        # Verifica se o arquivo existe antes de tentar abri-lo
        if not os.path.exists(filepath):
            messagebox.showerror("Erro", f"O arquivo não foi encontrado: {filepath}")
            return

        # Usando subprocess para abrir o arquivo
        subprocess.Popen(['start', '', filepath], shell=True)
    except Exception as e:
        messagebox.showerror("Erro", f"Erro ao abrir o arquivo: {e}")

# Função para preencher a treeview com os arquivos encontrados
def populate_tree():
    search_code = entry_code.get().strip()
    if not search_code:
        messagebox.showwarning("Entrada Vazia", "Por favor, insira um código para buscar.")
        return
    
    for item in tree.get_children():
        tree.delete(item)
    
    files = search_files(selected_directory, search_code)
    if not files:
        messagebox.showinfo("Nenhum Arquivo Encontrado", f"Nenhum arquivo encontrado com o código '{search_code}'.")
        return
    
    for idx, (filename, path, mod_time, formatted_time) in enumerate(files):
        tree.insert('', 'end', iid=idx, values=(filename, formatted_time, path))

# Função ao clicar no item da lista
def on_item_click(event):
    selected_items = tree.selection()
    if not selected_items:
        return
    selected_item = selected_items[0]
    file_path = tree.item(selected_item, 'values')[2]  # Obtém o caminho do arquivo
    print(f"Tentando abrir o arquivo: {file_path}")  # Debug: imprime o caminho do arquivo
    open_file(file_path)  # Chama a função para abrir o arquivo

# Função para escolher a pasta de busca
def choose_directory():
    global selected_directory
    selected_directory = filedialog.askdirectory(initialdir=base_path)
    if selected_directory:
        label_directory.config(text=f"Pasta atual: {selected_directory}")

# Caminho base
base_path = r"\\Fswcorp\ceic\DFEPJ\GAGIRE\22 - CARGA\arquivos_processados"
selected_directory = base_path  # Inicializa a pasta selecionada como a base

# Criação da interface gráfica
root = tk.Tk()
root.title("Buscar Arquivos por Código")
root.geometry("800x500")

# Frame de controle para entrada de código e botão
control_frame = ttk.Frame(root)
control_frame.pack(pady=10, padx=10, fill=tk.X)

# Label e Entry para o código de busca
label_code = ttk.Label(control_frame, text="Código:")
label_code.pack(side=tk.LEFT, padx=(0, 5))

entry_code = ttk.Entry(control_frame, width=20)
entry_code.pack(side=tk.LEFT, padx=(0, 10))
entry_code.bind("<Return>", lambda event: populate_tree())  # Permite buscar pressionando Enter

# Botão para carregar arquivos
btn_load = ttk.Button(control_frame, text="Buscar Arquivos", command=populate_tree)
btn_load.pack(side=tk.LEFT)

# Botão para escolher a pasta
btn_choose_directory = ttk.Button(control_frame, text="Escolher Pasta", command=choose_directory)
btn_choose_directory.pack(side=tk.LEFT, padx=(10, 0))

# Label para mostrar a pasta atual
label_directory = ttk.Label(control_frame, text=f"Pasta atual: {base_path}")
label_directory.pack(side=tk.LEFT, padx=(10, 0))

# Frame para Treeview e Scrollbar
tree_frame = ttk.Frame(root)
tree_frame.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

# Scrollbar vertical
tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL)
tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

# Scrollbar horizontal
tree_scroll_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)

# Treeview para listar os arquivos encontrados
columns = ('Nome do Arquivo', 'Data de Modificação', 'Caminho Completo')
tree = ttk.Treeview(tree_frame, columns=columns, show='headings',
                    yscrollcommand=tree_scroll.set, xscrollcommand=tree_scroll_x.set)
tree.heading('Nome do Arquivo', text='Nome do Arquivo')
tree.heading('Data de Modificação', text='Data de Modificação')
tree.heading('Caminho Completo', text='Caminho Completo')

tree.column('Nome do Arquivo', width=250, anchor='w')
tree.column('Data de Modificação', width=200, anchor='center')
tree.column('Caminho Completo', width=400, anchor='w')

tree.pack(fill=tk.BOTH, expand=True)

# Configuração das scrollbars
tree_scroll.config(command=tree.yview)
tree_scroll_x.config(command=tree.xview)

# Bind para detectar duplo clique no item da lista
tree.bind("<Double-1>", on_item_click)  # Chama on_item_click ao duplo clique

# Iniciar a interface
root.mainloop()