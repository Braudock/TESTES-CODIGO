import os
import tkinter as tk
from tkinter import messagebox, filedialog
from tkinter import ttk
import zipfile

# Função para buscar arquivos em pastas, subpastas e arquivos zipados
def search_files(base_paths, search_codes, specific_path):
    found_files = []
    
    for base_path in base_paths:
        for root, dirs, files in os.walk(base_path):
            # Verifica se o caminho específico é parte do diretório atual
            if specific_path and specific_path not in root:
                continue
            
            for file in files:
                full_path = os.path.join(root, file)

                # Verifica se o arquivo é um .zip
                if file.endswith(".zip"):
                    try:
                        # Abre o arquivo .zip
                        with zipfile.ZipFile(full_path, 'r') as z:
                            for zip_file in z.namelist():
                                # Verifica se o nome do arquivo no .zip contém os códigos de busca
                                for search_code in search_codes:
                                    if search_code in zip_file:
                                        # Adiciona no formato: "arquivo.zip -> arquivo_no_zip"
                                        found_files.append(f"{full_path} -> {zip_file}")
                    except zipfile.BadZipFile:
                        print(f"Arquivo zip corrompido: {full_path}")
                else:
                    # Verifica se o arquivo atende aos critérios normais
                    for search_code in search_codes:
                        if search_code in file:
                            found_files.append(full_path)
    
    return found_files

# Função para abrir o arquivo selecionado
def open_file(filepath):
    try:
        if " -> " in filepath:  # Caso seja de dentro de um .zip
            zip_path, inner_file = filepath.split(" -> ")
            with zipfile.ZipFile(zip_path, 'r') as z:
                z.extract(inner_file, os.path.dirname(zip_path))
                extracted_path = os.path.join(os.path.dirname(zip_path), inner_file)
                if os.name == "nt":
                    os.startfile(extracted_path)
                else:
                    subprocess.call(["xdg-open", extracted_path])
        else:
            if os.name == "nt":
                os.startfile(filepath)
            else:
                subprocess.call(["xdg-open", filepath])
    except Exception as e:
        messagebox.showerror("Erro", f"Erro ao abrir o arquivo: {e}")

# Função para preencher a Treeview com os arquivos encontrados
def populate_tree():
    search_codes = entry_code.get().strip().split()
    specific_path = entry_specific_path.get().strip()
    
    if not search_codes or search_codes == [""]:
        messagebox.showwarning("Entrada Vazia", "Por favor, insira um ou mais códigos para buscar.")
        return

    # Limpa a Treeview antes de inserir novos dados
    for item in tree.get_children():
        tree.delete(item)
    
    files = search_files(base_paths, search_codes, specific_path)
    if not files:
        messagebox.showinfo("Nenhum Arquivo Encontrado", "Nenhum arquivo encontrado com os códigos especificados.")
    else:
        for idx, filepath in enumerate(files):
            tree.insert("", "end", iid=idx, values=(filepath,))

# Função para selecionar pastas base
def select_base_paths():
    folder_selected = filedialog.askdirectory()
    if folder_selected:
        base_paths.append(folder_selected)
        label_base_paths.config(text="Caminhos base: " + ", ".join(base_paths))

# Função ao clicar no item da lista
def on_item_click(event):
    selected_items = tree.selection()
    if not selected_items:
        return
    selected_item = selected_items[0]
    file_path = tree.item(selected_item, "values")[0]
    open_file(file_path)

# Caminhos base
base_paths = []

# Interface gráfica
root = tk.Tk()
root.title("Buscar Arquivos por Código")
root.geometry("800x600")

# Frame de controle para entrada de código e botões
control_frame = tk.Frame(root)
control_frame.pack(padx=10, pady=10, fill=tk.X)

# Botão para selecionar pastas base
btn_select_paths = ttk.Button(control_frame, text="Selecionar Caminhos Base", command=select_base_paths)
btn_select_paths.pack(side=tk.LEFT)

# Label para mostrar os caminhos base selecionados
label_base_paths = tk.Label(control_frame, text="Caminhos base: Nenhum selecionado", anchor="w", justify="left")
label_base_paths.pack(fill=tk.X, padx=10, pady=5)

# Label e entrada para o código de busca
label_code = tk.Label(control_frame, text="Código(s) de Busca:")
label_code.pack(side=tk.LEFT, padx=5)
entry_code = ttk.Entry(control_frame, width=40)
entry_code.pack(side=tk.LEFT, padx=5)
entry_code.bind("<Return>", lambda event: populate_tree())  # Permite buscar pressionando Enter

# Label e entrada para o caminho específico
label_specific_path = tk.Label(control_frame, text="Caminho Específico:")
label_specific_path.pack(side=tk.LEFT, padx=5)
entry_specific_path = ttk.Entry(control_frame, width=40)
entry_specific_path.pack(side=tk.LEFT, padx=5)

# Botão para carregar arquivos
btn_load = ttk.Button(control_frame, text="Buscar Arquivos", command=populate_tree)
btn_load.pack(side=tk.LEFT)

# Frame para Treeview e Scrollbar
tree_frame = ttk.Frame(root)
tree_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

# Scrollbar vertical
tree_scroll_y = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL)
tree_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)

# Scrollbar horizontal
tree_scroll_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)

# Treeview para listar os arquivos encontrados
tree = ttk.Treeview(tree_frame, columns=("Caminho Completo",), show="headings", yscrollcommand=tree_scroll_y.set, xscrollcommand=tree_scroll_x.set)
tree.heading("Caminho Completo", text="Caminho Completo")
tree.column("Caminho Completo", anchor="w")
tree.pack(fill=tk.BOTH, expand=True)

# Configuração das scrollbars
tree_scroll_y.config(command=tree.yview)
tree_scroll_x.config(command=tree.xview)

# Bind para detectar duplo clique no item da lista
tree.bind("<Double-1>", on_item_click)

# Iniciar a interface
root.mainloop()