import os
import tkinter as tk
from tkinter import messagebox, filedialog
from tkinter import ttk
import subprocess
from datetime import datetime
import tkinter.font as tkFont
from openpyxl import Workbook  # Importando a biblioteca openpyxl

# Função para buscar arquivos com o(s) código(s) no nome e ordenar pela data de modificação
def search_files(base_paths, search_codes, specific_path):
    found_files = []
    for base_path in base_paths:
        for root, dirs, files in os.walk(base_path):
            # Verifica se o caminho específico é parte do caminho do arquivo
            if specific_path and specific_path not in root:
                continue  # Se o caminho específico não estiver no diretório atual, ignora
            for file in files:
                for search_code in search_codes:
                    if search_code in file and file.endswith('.txt'):
                        full_path = os.path.join(root, file)
                        mod_time = os.path.getmtime(full_path)
                        formatted_time = datetime.fromtimestamp(mod_time).strftime("%Y-%m-%d %H:%M:%S")
                        found_files.append((file, full_path, mod_time, formatted_time))
    
    # Ordena do mais recente para o mais antigo pela data de modificação (mod_time)
    found_files.sort(key=lambda x: x[2], reverse=True)
    return found_files

# Função para abrir o arquivo selecionado
def open_file(filepath):
    try:
        if os.name == 'nt':  # Windows
            os.startfile(filepath)
        else:  # Linux/Mac
            subprocess.call(['xdg-open', filepath])
    except Exception as e:
        messagebox.showerror("Erro", f"Erro ao abrir o arquivo: {e}")

# Função para preencher a Treeview com os arquivos encontrados
def populate_tree():
    search_codes = entry_code.get().strip().split(",")
    specific_path = entry_specific_path.get().strip()  # Pega o caminho específico para filtrar
    if not search_codes or search_codes == ['']:
        messagebox.showwarning("Entrada Vazia", "Por favor, insira um ou mais códigos para buscar.")
        return

    # Limpa a Treeview antes de inserir novos dados
    for item in tree.get_children():
        tree.delete(item)
    
    files = search_files(base_paths, search_codes, specific_path)
    if not files:
        messagebox.showinfo("Nenhum Arquivo Encontrado", "Nenhum arquivo encontrado com os códigos especificados.")
    else:
        for idx, (filename, path, mod_time, formatted_time) in enumerate(files):
            tree.insert('', 'end', iid=idx, values=(filename, formatted_time, path))

        # Ajusta a largura das colunas
        for col in tree["columns"]:
            # Configura largura inicial baseada nos cabeçalhos
            tree.column(col, width=tkFont.Font().measure(col), anchor='w')
            for item in tree.get_children():
                value = tree.item(item, 'values')[tree["columns"].index(col)]
                tree.column(col, width=max(tree.column(col)["width"], tkFont.Font().measure(value)))

# Função ao clicar no item da lista
def on_item_click(event):
    selected_items = tree.selection()
    if not selected_items:
        return
    selected_item = selected_items[0]
    file_path = tree.item(selected_item, 'values')[2]
    open_file(file_path)

# Função para selecionar pastas base
def select_base_paths():
    folder_selected = filedialog.askdirectory()
    if folder_selected:
        base_paths.append(folder_selected)
        label_base_paths.config(text="Caminhos base: " + ", ".join(base_paths))

# Função para exportar dados da Treeview para um arquivo Excel
def export_to_excel():
    files = []
    for item in tree.get_children():
        files.append(tree.item(item, 'values'))
    
    if not files:
        messagebox.showwarning("Exportação", "Nenhum dado para exportar.")
        return
    
    save_path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")])
    if save_path:
        try:
            wb = Workbook()
            ws = wb.active
            ws.title = "Arquivos Encontrados"
            # Adiciona cabeçalho
            ws.append(["Nome do Arquivo", "Data de Modificação", "Caminho Completo"])
            # Adiciona dados
            for file in files:
                ws.append(file)
            wb.save(save_path)  # Salva o arquivo
            messagebox.showinfo("Exportação", "Dados exportados com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar os dados: {e}")

# Caminhos base
base_paths = []

# Interface gráfica
root = tk.Tk()
root.title("Buscar Arquivos por Código")
root.geometry("800x500")

# Frame de controle para entrada de código e botões
control_frame = tk.Frame(root)
control_frame.pack(padx=10, pady=10, fill=tk.X)

# Botão para selecionar pastas base
btn_select_paths = ttk.Button(control_frame, text="Selecionar Caminhos Base", command=select_base_paths)
btn_select_paths.pack(side=tk.LEFT)

# Label para mostrar os caminhos base selecionados
label_base_paths = tk.Label(control_frame, text="Caminhos base: Nenhum selecionado", anchor="w", justify="left")
label_base_paths.pack(fill=tk.X, padx=10, pady=5)

# Label e entrada para o código de busca
label_code = tk.Label(control_frame, text="Código(s) de Busca:")
label_code.pack(side=tk.LEFT, padx=5)
entry_code = ttk.Entry(control_frame, width=40)
entry_code.pack(side=tk.LEFT, padx=5)
entry_code.bind('<Return>', lambda event: populate_tree())  # Permite buscar pressionando Enter

# Label e entrada para o caminho específico
label_specific_path = tk.Label(control_frame, text="Caminho Específico:")
label_specific_path.pack(side=tk.LEFT, padx=5)
entry_specific_path = ttk.Entry(control_frame, width=40)
entry_specific_path.pack(side=tk.LEFT, padx=5)

# Botão para carregar arquivos
btn_load = ttk.Button(control_frame, text="Buscar Arquivos", command=populate_tree)
btn_load.pack(side=tk.LEFT)

# Botão para exportar dados
btn_export = ttk.Button(control_frame, text="Exportar Excel", command=export_to_excel)
btn_export.pack(side=tk.LEFT)

# Frame para Treeview e Scrollbar
tree_frame = ttk.Frame(root)
tree_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

# Scrollbar vertical
tree_scroll_y = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL)
tree_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)

# Scrollbar horizontal
tree_scroll_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)

# Treeview para listar os arquivos encontrados
tree = ttk.Treeview(tree_frame, columns=["Nome do Arquivo", "Data de Modificação", "Caminho Completo"], 
                    yscrollcommand=tree_scroll_y.set, xscrollcommand=tree_scroll_x.set)
tree.heading('Nome do Arquivo', text='Nome do Arquivo')
tree.heading('Data de Modificação', text='Data de Modificação')
tree.heading('Caminho Completo', text='Caminho Completo')
tree.column('Nome do Arquivo', anchor='w')
tree.column('Data de Modificação', anchor='center')
tree.column('Caminho Completo', anchor='w')
tree.pack(fill=tk.BOTH, expand=True)

# Configuração das scrollbars
tree_scroll_y.config(command=tree.yview)
tree_scroll_x.config(command=tree.xview)

# Bind para detectar duplo clique no item da lista
tree.bind("<Double-1>", on_item_click)

# Iniciar a interface
root.mainloop()